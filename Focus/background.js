const MOTIVATIONAL_QUOTES = [{ content: "The only way to do great work is to love what you do.", author: "Steve Jobs" }, { content: "Focus on being productive instead of busy.", author: "Tim Ferriss" }, { content: "The best way to predict the future is to create it.", author: "Peter Drucker" }, { content: "It's not that I'm so smart, it's just that I stay with problems longer.", author: "Albert Einstein" }, { content: "Concentrate all your thoughts upon the work at hand.", author: "Alexander Graham Bell" }, { content: "The successful warrior is the average man, with laser-like focus.", author: "Bruce Lee" }, { content: "Where focus goes, energy flows.", author: "Tony Robbins" }, { content: "Starve your distractions, feed your focus.", author: "Unknown" }, { content: "You can't depend on your eyes when your imagination is out of focus.", author: "Mark Twain" }, { content: "Lack of direction, not lack of time, is the problem.", author: "Zig Ziglar" }];
const POMODORO_WORK = 25;
const POMODORO_BREAK = 5;
const POMODORO_LONG_BREAK = 15;
chrome.runtime.onInstalled.addListener(() => { chrome.storage.local.set({ enabled: true, duration: 25, isRunning: false, timeLeft: 25 * 60, blocklist: ["youtube.com", "facebook.com", "twitter.com"], allSites: [{ domain: "youtube.com", name: "YouTube" }, { domain: "facebook.com", name: "Facebook" }, { domain: "twitter.com", name: "Twitter/X" }, { domain: "instagram.com", name: "Instagram" }, { domain: "reddit.com", name: "Reddit" }, { domain: "tiktok.com", name: "TikTok" }, { domain: "netflix.com", name: "Netflix" }, { domain: "twitch.tv", name: "Twitch" }], whitelist: ["google.com", "gmail.com", "github.com"], whitelistMode: false, passwordHash: null, pomodoroEnabled: false, pomodoroPhase: 'work', pomodoroCount: 0, scheduleEnabled: false, scheduleStart: '09:00', scheduleEnd: '17:00', scheduleDays: [1, 2, 3, 4, 5], theme: 'dark', soundEnabled: true, totalFocusTime: 0, sessionsCompleted: 0, currentStreak: 0, lastSessionDate: null, siteTimeData: {} }); chrome.alarms.create('scheduleCheck', { periodInMinutes: 1 }); });
chrome.alarms.onAlarm.addListener((alarm) => { if (alarm.name === "focustimer") tick(); if (alarm.name === "scheduleCheck") checkSchedule(); });
async function tick() { const data = await chrome.storage.local.get(["timeLeft", "isRunning", "pomodoroEnabled", "pomodoroPhase", "pomodoroCount", "duration"]); if (!data.isRunning) return; let newTime = data.timeLeft - 1; if (newTime <= 0) { if (data.pomodoroEnabled) { await handlePomodoroComplete(data); } else { await completeTimer(); } } else { chrome.storage.local.set({ timeLeft: newTime }); } }
async function handlePomodoroComplete(data) { const phase = data.pomodoroPhase || 'work'; let nextPhase, nextDuration, nextCount; if (phase === 'work') { nextCount = (data.pomodoroCount || 0) + 1; if (nextCount >= 4) { nextPhase = 'break'; nextDuration = POMODORO_LONG_BREAK; nextCount = 0; } else { nextPhase = 'break'; nextDuration = POMODORO_BREAK; } const stats = await chrome.storage.local.get(['totalFocusTime', 'sessionsCompleted', 'lastSessionDate', 'currentStreak']); const today = new Date().toDateString(); let streak = stats.currentStreak || 0; if (stats.lastSessionDate !== today) { const yesterday = new Date(Date.now() - 86400000).toDateString(); streak = (stats.lastSessionDate === yesterday) ? streak + 1 : 1; } await chrome.storage.local.set({ totalFocusTime: (stats.totalFocusTime || 0) + POMODORO_WORK, sessionsCompleted: (stats.sessionsCompleted || 0) + 1, lastSessionDate: today, currentStreak: streak }); chrome.notifications.create({ type: 'basic', iconUrl: chrome.runtime.getURL('images/icon.png'), title: 'Work Phase Complete!', message: `Time for a ${nextDuration} minute break.`, priority: 2 }); } else { nextPhase = 'work'; nextDuration = POMODORO_WORK; nextCount = data.pomodoroCount || 0; chrome.notifications.create({ type: 'basic', iconUrl: chrome.runtime.getURL('images/icon.png'), title: 'Break Over!', message: 'Back to focused work.', priority: 2 }); } await chrome.storage.local.set({ pomodoroPhase: nextPhase, pomodoroCount: nextCount, timeLeft: nextDuration * 60, duration: nextDuration }); }
async function startTimer() { const data = await chrome.storage.local.get(["duration", "blocklist", "pomodoroEnabled"]); let duration = data.duration || 25; if (data.pomodoroEnabled) { duration = POMODORO_WORK; } await chrome.storage.local.set({ timeLeft: duration * 60, isRunning: true, duration: duration, pomodoroPhase: 'work' }); chrome.alarms.create("focustimer", { periodInMinutes: 1 / 60 }); await reloadBlockedTabs(data.blocklist || []); chrome.action.setBadgeText({ text: "ON" }); chrome.action.setBadgeBackgroundColor({ color: "#7c4dff" }); }
async function stopTimer() { chrome.alarms.clear("focustimer"); await chrome.storage.local.set({ isRunning: false }); chrome.action.setBadgeText({ text: "" }); }
async function completeTimer() { chrome.alarms.clear("focustimer"); const data = await chrome.storage.local.get(["duration", "totalFocusTime", "sessionsCompleted", "lastSessionDate", "currentStreak"]); const today = new Date().toDateString(); let streak = data.currentStreak || 0; if (data.lastSessionDate !== today) { const yesterday = new Date(Date.now() - 86400000).toDateString(); streak = (data.lastSessionDate === yesterday) ? streak + 1 : 1; } await chrome.storage.local.set({ isRunning: false, totalFocusTime: (data.totalFocusTime || 0) + (data.duration || 25), sessionsCompleted: (data.sessionsCompleted || 0) + 1, lastSessionDate: today, currentStreak: streak }); chrome.action.setBadgeText({ text: "" }); chrome.notifications.create({ type: 'basic', iconUrl: chrome.runtime.getURL('images/icon.png'), title: 'Focus Session Complete!', message: `Great job! You focused for ${data.duration || 25} minutes.`, priority: 2 }); }
async function checkSchedule() { const data = await chrome.storage.local.get(['scheduleEnabled', 'scheduleStart', 'scheduleEnd', 'scheduleDays', 'isRunning', 'blocklist']); if (!data.scheduleEnabled || data.isRunning) return; const now = new Date(); const day = now.getDay(); const time = now.toTimeString().slice(0, 5); if (!data.scheduleDays.includes(day)) return; if (time >= data.scheduleStart && time <= data.scheduleEnd) { await startTimer(); } }
async function reloadBlockedTabs(blocklist) { if (!blocklist || blocklist.length === 0) return; const tabs = await chrome.tabs.query({}); for (const tab of tabs) { if (!tab.url) continue; try { const url = new URL(tab.url); const hostname = url.hostname.toLowerCase().replace('www.', ''); const isBlocked = blocklist.some(domain => { const cleanDomain = domain.trim().toLowerCase().replace('www.', ''); return hostname.includes(cleanDomain); }); if (isBlocked) { chrome.tabs.reload(tab.id); } } catch (e) { } } }
async function trackSiteTime(domain, seconds) { const data = await chrome.storage.local.get('siteTimeData'); const siteTimeData = data.siteTimeData || {}; siteTimeData[domain] = (siteTimeData[domain] || 0) + seconds; await chrome.storage.local.set({ siteTimeData }); }
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { switch (request.cmd) { case "PING": sendResponse({ success: true, payload: "PONG-v2.0" }); break; case "START_TIMER": startTimer().then(() => sendResponse({ success: true })); return true; case "STOP_TIMER": stopTimer().then(() => sendResponse({ success: true })); return true; case "GET_QUOTE": const quote = MOTIVATIONAL_QUOTES[Math.floor(Math.random() * MOTIVATIONAL_QUOTES.length)]; sendResponse({ success: true, data: quote }); break; case "GET_RANDOM_QUOTE": const randomQuote = MOTIVATIONAL_QUOTES[Math.floor(Math.random() * MOTIVATIONAL_QUOTES.length)]; sendResponse({ success: true, quote: randomQuote }); break; case "TRACK_TIME": trackSiteTime(request.domain, request.seconds).then(() => { sendResponse({ success: true }); }); return true; case "GET_DOG": fetch("https://dog.ceo/api/breeds/image/random").then(r => r.json()).then(data => sendResponse({ success: true, url: data.message })).catch(err => sendResponse({ success: false, error: err.toString() })); return true; default: sendResponse({ success: false, error: "Unknown command" }); }return true; });