const el = { tabBtns: document.querySelectorAll('.tab-btn'), tabContents: document.querySelectorAll('.tab-content'), timer: document.getElementById('timer'), progressRing: document.getElementById('progressRing'), startBtn: document.getElementById('startBtn'), resetBtn: document.getElementById('resetBtn'), presetBtns: document.querySelectorAll('.preset-btn'), pomodoroStatus: document.getElementById('pomodoroStatus'), phaseLabel: document.getElementById('phaseLabel'), cycleCount: document.getElementById('cycleCount'), blockModeBtn: document.getElementById('blockModeBtn'), whiteModeBtn: document.getElementById('whiteModeBtn'), modeHint: document.getElementById('modeHint'), siteList: document.getElementById('siteList'), customDomain: document.getElementById('customDomain'), addCustomBtn: document.getElementById('addCustomBtn'), whitelistCurrentBtn: document.getElementById('whitelistCurrentBtn'), passwordInput: document.getElementById('passwordInput'), setPasswordBtn: document.getElementById('setPasswordBtn'), passwordStatus: document.getElementById('passwordStatus'), statTotalTime: document.getElementById('statTotalTime'), statSessions: document.getElementById('statSessions'), statStreak: document.getElementById('statStreak'), siteTimeList: document.getElementById('siteTimeList'), themeToggle: document.getElementById('themeToggle'), soundToggle: document.getElementById('soundToggle'), pomodoroToggle: document.getElementById('pomodoroToggle'), scheduleToggle: document.getElementById('scheduleToggle'), scheduleConfig: document.getElementById('scheduleConfig'), scheduleStart: document.getElementById('scheduleStart'), scheduleEnd: document.getElementById('scheduleEnd'), dayBtns: document.querySelectorAll('.day-btn'), toggle: document.getElementById('toggle'), statusText: document.getElementById('statusText'), pingBtn: document.getElementById('pingBtn'), quoteBtn: document.getElementById('quoteBtn'), dogBtn: document.getElementById('dogBtn'), apiResult: document.getElementById('apiResult') };
const DEFAULT_SITES = [{ domain: "youtube.com", name: "YouTube" }, { domain: "facebook.com", name: "Facebook" }, { domain: "twitter.com", name: "Twitter/X" }, { domain: "instagram.com", name: "Instagram" }, { domain: "reddit.com", name: "Reddit" }, { domain: "tiktok.com", name: "TikTok" }, { domain: "netflix.com", name: "Netflix" }, { domain: "twitch.tv", name: "Twitch" }];
let state = { duration: 25, timeLeft: 25 * 60, isRunning: false, blocklist: ["facebook.com", "instagram.com", "tiktok.com", "reddit.com"], whitelist: ["google.com", "gmail.com", "github.com"], allSites: [...DEFAULT_SITES], whitelistMode: false, passwordHash: null, pomodoroEnabled: false, pomodoroPhase: 'work', pomodoroCount: 0, scheduleEnabled: false, scheduleDays: [1, 2, 3, 4, 5], scheduleStart: '09:00', scheduleEnd: '17:00', theme: 'dark', soundEnabled: true, totalFocusTime: 0, sessionsCompleted: 0, currentStreak: 0, siteTimeData: {} };
let uiInterval = null;
const RING_CIRCUMFERENCE = 2 * Math.PI * 80;
function getFavicon(domain) { return `https://www.google.com/s2/favicons?domain=${domain}&sz=32`; }
async function callBG(cmd, data = {}) { return new Promise((resolve) => { chrome.runtime.sendMessage({ cmd, ...data }, (response) => { if (chrome.runtime.lastError) { resolve({ success: false, error: chrome.runtime.lastError.message }); } else { resolve(response || { success: false }); } }); }); }
function formatTime(seconds) { const m = Math.floor(seconds / 60); const s = seconds % 60; return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
function formatDuration(minutes) { if (minutes < 60) return `${minutes}m`; const h = Math.floor(minutes / 60); const m = minutes % 60; return m > 0 ? `${h}h ${m}m` : `${h}h`; }
function simpleHash(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = ((hash << 5) - hash) + str.charCodeAt(i); hash |= 0; } return hash.toString(); }
async function init() { const data = await chrome.storage.local.get(null); state = { ...state, ...data }; if (data.allSites) state.allSites = data.allSites; if (data.blocklist) state.blocklist = data.blocklist; if (data.whitelist) state.whitelist = data.whitelist; if (state.whitelistMode) { el.whiteModeBtn.classList.add('active'); el.blockModeBtn.classList.remove('active'); el.modeHint.textContent = 'Only these sites will be ACCESSIBLE'; } else { el.blockModeBtn.classList.add('active'); el.whiteModeBtn.classList.remove('active'); el.modeHint.textContent = 'External sites will be BLOCKED'; } updateGlobalStatus(state.enabled); if (state.theme === 'light') { document.body.classList.add('light-theme'); el.themeToggle.checked = false; } updateTimerDisplay(); updateProgressRing(); renderSiteList(); updateStats(); loadSettings(); if (state.isRunning) { startUISync(); } el.presetBtns.forEach(btn => { btn.classList.toggle('active', parseInt(btn.dataset.mins) === state.duration); }); }
el.tabBtns.forEach(btn => { btn.onclick = () => { const tabId = btn.dataset.tab; el.tabBtns.forEach(b => b.classList.remove('active')); el.tabContents.forEach(c => c.classList.remove('active')); btn.classList.add('active'); document.getElementById(`tab-${tabId}`).classList.add('active'); playSound('switch'); }; });
function updateTimerDisplay() { el.timer.textContent = formatTime(state.timeLeft); }
function updateProgressRing() { const total = state.duration * 60; const progress = state.timeLeft / total; const offset = RING_CIRCUMFERENCE * (1 - progress); el.progressRing.style.strokeDasharray = RING_CIRCUMFERENCE; el.progressRing.style.strokeDashoffset = offset; }
el.presetBtns.forEach(btn => { btn.onclick = () => { if (state.isRunning) return; const mins = parseInt(btn.dataset.mins); state.duration = mins; state.timeLeft = mins * 60; el.presetBtns.forEach(b => b.classList.remove('active')); btn.classList.add('active'); chrome.storage.local.set({ duration: mins, timeLeft: mins * 60 }); updateTimerDisplay(); updateProgressRing(); playSound('click'); }; });
el.startBtn.onclick = async () => { if (state.isRunning) { if (state.passwordHash) { const pwd = prompt('Enter password to stop:'); if (!pwd || simpleHash(pwd) !== state.passwordHash) { el.apiResult.textContent = 'Wrong password!'; return; } } await callBG('STOP_TIMER'); stopUISync(); playSound('stop'); } else { await callBG('START_TIMER'); startUISync(); playSound('start'); } };
el.resetBtn.onclick = async () => { if (state.passwordHash && state.isRunning) { const pwd = prompt('Enter password to reset:'); if (!pwd || simpleHash(pwd) !== state.passwordHash) { el.apiResult.textContent = 'Wrong password!'; return; } } await callBG('STOP_TIMER'); stopUISync(); state.timeLeft = state.duration * 60; chrome.storage.local.set({ timeLeft: state.timeLeft }); updateTimerDisplay(); updateProgressRing(); };
function startUISync() { state.isRunning = true; el.startBtn.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2.5" fill="currentColor" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg><span>Pause</span>`; el.startBtn.style.background = 'var(--danger)'; if (state.pomodoroEnabled) { el.pomodoroStatus.style.display = 'flex'; } if (uiInterval) clearInterval(uiInterval); uiInterval = setInterval(async () => { const data = await chrome.storage.local.get(['timeLeft', 'isRunning', 'pomodoroPhase', 'pomodoroCount']); state.timeLeft = data.timeLeft; state.isRunning = data.isRunning; updateTimerDisplay(); updateProgressRing(); if (state.pomodoroEnabled) { state.pomodoroPhase = data.pomodoroPhase || 'work'; state.pomodoroCount = data.pomodoroCount || 0; const icon = state.pomodoroPhase === 'work' ? '<svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="3" fill="none" style="margin-right:4px"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>' : '<svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none" style="margin-right:4px"><path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line></svg>'; el.phaseLabel.innerHTML = `${icon}<span>${state.pomodoroPhase.toUpperCase()}</span>`; el.phaseLabel.className = `phase-label ${state.pomodoroPhase}`; el.cycleCount.textContent = state.pomodoroCount + 1; } if (!data.isRunning) { stopUISync(); if (state.soundEnabled) playSound('complete'); updateStats(); } }, 500); }
function stopUISync() { state.isRunning = false; el.startBtn.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2.5" fill="currentColor" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><span>Start Focus</span>`; el.startBtn.style.background = 'var(--primary)'; el.pomodoroStatus.style.display = 'none'; if (uiInterval) clearInterval(uiInterval); }
function renderSiteList() { el.siteList.innerHTML = ''; const currentList = state.whitelistMode ? state.whitelist : state.blocklist; const filterSites = state.whitelistMode ? state.whitelist : state.blocklist; const sitesToShow = state.whitelistMode ? state.whitelist.map(d => ({ domain: d, name: d })) : state.allSites; sitesToShow.forEach(site => { const isActive = currentList.includes(site.domain); const item = document.createElement('div'); item.className = `site-item ${isActive ? 'blocked' : ''}`; item.innerHTML = `<img src="${getFavicon(site.domain)}" alt="" class="site-icon"><span class="site-name">${site.name}</span><span class="site-domain">${site.domain}</span><div class="toggle-switch ${isActive ? 'active' : ''}" data-domain="${site.domain}"><div class="toggle-knob"></div></div>`; item.querySelector('.toggle-switch').onclick = () => toggleSite(site.domain); el.siteList.appendChild(item); }); }
function toggleSite(domain) { let targetList = state.whitelistMode ? state.whitelist : state.blocklist; if (targetList.includes(domain)) { targetList = targetList.filter(d => d !== domain); } else { targetList.push(domain); } if (state.whitelistMode) { state.whitelist = targetList; chrome.storage.local.set({ whitelist: state.whitelist }); } else { state.blocklist = targetList; chrome.storage.local.set({ blocklist: state.blocklist }); } renderSiteList(); playSound('toggle'); }
el.addCustomBtn.onclick = addCustomSite;
el.customDomain.onkeypress = (e) => { if (e.key === 'Enter') addCustomSite(); };
function addCustomSite() { let domain = el.customDomain.value.trim().toLowerCase(); if (!domain) return; if (state.whitelistMode) { if (!state.whitelist.includes(domain)) state.whitelist.push(domain); chrome.storage.local.set({ whitelist: state.whitelist }); } else { if (!state.allSites.some(s => s.domain === domain)) { state.allSites.push({ domain, name: domain }); chrome.storage.local.set({ allSites: state.allSites }); } if (!state.blocklist.includes(domain)) state.blocklist.push(domain); chrome.storage.local.set({ blocklist: state.blocklist }); } el.customDomain.value = ''; renderSiteList(); playSound('success'); }
el.blockModeBtn.onclick = () => { state.whitelistMode = false; el.blockModeBtn.classList.add('active'); el.whiteModeBtn.classList.remove('active'); el.modeHint.textContent = 'External sites will be BLOCKED'; chrome.storage.local.set({ whitelistMode: false }); renderSiteList(); playSound('switch'); };
el.whiteModeBtn.onclick = () => { state.whitelistMode = true; el.whiteModeBtn.classList.add('active'); el.blockModeBtn.classList.remove('active'); el.modeHint.textContent = 'Only these sites will be ACCESSIBLE'; chrome.storage.local.set({ whitelistMode: true }); renderSiteList(); playSound('switch'); };
el.setPasswordBtn.onclick = () => { const pwd = el.passwordInput.value.trim(); if (pwd.length < 4) { el.passwordStatus.textContent = 'Min 4 characters'; return; } state.passwordHash = simpleHash(pwd); chrome.storage.local.set({ passwordHash: state.passwordHash }); el.passwordStatus.textContent = 'Password set!'; el.passwordInput.value = ''; playSound('success'); };
function updateStats() { chrome.storage.local.get(['totalFocusTime', 'sessionsCompleted', 'currentStreak', 'siteTimeData'], (data) => { const total = data.totalFocusTime || 0; el.statTotalTime.textContent = formatDuration(total); el.statSessions.textContent = data.sessionsCompleted || 0; el.statStreak.textContent = data.currentStreak || 0; const siteData = data.siteTimeData || {}; const sites = Object.entries(siteData).sort((a, b) => b[1] - a[1]); if (sites.length === 0) { el.siteTimeList.innerHTML = '<p class="empty-state">No tracking data yet</p>'; return; } const maxTime = sites[0][1]; el.siteTimeList.innerHTML = sites.slice(0, 10).map(([domain, seconds]) => { const pct = Math.round((seconds / maxTime) * 100); const mins = Math.round(seconds / 60); return `<div class="site-time-item"><img src="${getFavicon(domain)}" class="site-icon"><span class="domain">${domain}</span><span class="time">${mins}m</span></div><div class="site-time-bar"><div class="site-time-bar-fill" style="width:${pct}%"></div></div>`; }).join(''); }); }
function loadSettings() { el.whitelistToggle.checked = state.whitelistMode; el.modeHint.textContent = state.whitelistMode ? 'Only sites below will be ALLOWED' : 'Sites below will be BLOCKED'; el.soundToggle.checked = state.soundEnabled; el.pomodoroToggle.checked = state.pomodoroEnabled; el.scheduleToggle.checked = state.scheduleEnabled; el.scheduleStart.value = state.scheduleStart; el.scheduleEnd.value = state.scheduleEnd; el.scheduleConfig.style.display = state.scheduleEnabled ? 'block' : 'none'; if (state.passwordHash) { el.passwordStatus.textContent = 'Password is set'; } el.dayBtns.forEach(btn => { btn.classList.toggle('active', state.scheduleDays.includes(parseInt(btn.dataset.day))); }); }
el.themeToggle.onchange = () => { const isDark = el.themeToggle.checked; state.theme = isDark ? 'dark' : 'light'; document.body.classList.toggle('light-theme', !isDark); chrome.storage.local.set({ theme: state.theme }); playSound('toggle'); };
el.soundToggle.onchange = () => { state.soundEnabled = el.soundToggle.checked; chrome.storage.local.set({ soundEnabled: state.soundEnabled }); playSound('toggle'); };
el.pomodoroToggle.onchange = () => { state.pomodoroEnabled = el.pomodoroToggle.checked; chrome.storage.local.set({ pomodoroEnabled: state.pomodoroEnabled }); playSound('toggle'); };
el.scheduleToggle.onchange = () => { state.scheduleEnabled = el.scheduleToggle.checked; el.scheduleConfig.style.display = state.scheduleEnabled ? 'block' : 'none'; chrome.storage.local.set({ scheduleEnabled: state.scheduleEnabled }); playSound('toggle'); };
el.scheduleStart.onchange = () => { state.scheduleStart = el.scheduleStart.value; chrome.storage.local.set({ scheduleStart: state.scheduleStart }); };
el.scheduleEnd.onchange = () => { state.scheduleEnd = el.scheduleEnd.value; chrome.storage.local.set({ scheduleEnd: state.scheduleEnd }); };
el.dayBtns.forEach(btn => { btn.onclick = () => { const day = parseInt(btn.dataset.day); if (state.scheduleDays.includes(day)) { state.scheduleDays = state.scheduleDays.filter(d => d !== day); } else { state.scheduleDays.push(day); } btn.classList.toggle('active'); chrome.storage.local.set({ scheduleDays: state.scheduleDays }); }; });
let audioCtx = null;
function playSound(type) { if (!state.soundEnabled) return; try { if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } if (audioCtx.state === 'suspended') { audioCtx.resume(); } const masterGain = audioCtx.createGain(); masterGain.connect(audioCtx.destination); masterGain.gain.setValueAtTime(0, audioCtx.currentTime); const playTone = (freqs, duration, volume = 0.2, oscType = 'sine', stagger = 0.05) => { freqs.forEach((freq, i) => { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = oscType; osc.frequency.setValueAtTime(freq, audioCtx.currentTime); osc.connect(g); g.connect(masterGain); const start = audioCtx.currentTime + (i * stagger); g.gain.setValueAtTime(0, start); g.gain.linearRampToValueAtTime(volume / freqs.length, start + 0.1); g.gain.exponentialRampToValueAtTime(0.001, start + duration); osc.start(start); osc.stop(start + duration + 0.1); }); masterGain.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.05); }; switch (type) { case 'start': playTone([880, 1108, 1318], 1.2, 0.12); break; case 'stop': playTone([440], 0.15, 0.04); break; case 'complete': playTone([196, 293, 392, 440], 4.0, 0.25); break; case 'click': playTone([1760], 0.08, 0.03); break; case 'toggle': playTone([660, 523], 0.3, 0.08, 'sine', 0.1); break; case 'switch': playTone([2200, 1800], 0.1, 0.02, 'sine', 0.02); break; case 'success': playTone([659, 880, 1046], 0.6, 0.1, 'sine', 0.05); break; } } catch (e) { console.error("Audio error", e); } }
function updateGlobalStatus(enabled) { el.toggle.classList.toggle('on', enabled); el.statusText.textContent = enabled ? 'ON' : 'OFF'; }
el.toggle.onclick = async () => { state.enabled = !state.enabled; if (!state.enabled) { await callBG('STOP_TIMER'); stopUISync(); playSound('stop'); } else { playSound('start'); } chrome.storage.local.set({ enabled: state.enabled }, () => { updateGlobalStatus(state.enabled); }); };
el.whitelistCurrentBtn.onclick = async () => { const tabs = await chrome.tabs.query({ active: true, currentWindow: true }); if (!tabs[0]?.url) return; try { let url = new URL(tabs[0].url); let domain = url.hostname.replace('www.', ''); if (state.whitelistMode) { if (!state.whitelist.includes(domain)) state.whitelist.push(domain); chrome.storage.local.set({ whitelist: state.whitelist }); el.apiResult.textContent = `Whitelisted ${domain}`; } else { state.blocklist = state.blocklist.filter(d => d !== domain); chrome.storage.local.set({ blocklist: state.blocklist }); el.apiResult.textContent = `Unblocked ${domain}`; } renderSiteList(); playSound('success'); } catch (e) { el.apiResult.textContent = 'Invalid URL'; } };
el.pingBtn.onclick = async () => { const res = await callBG('PING'); el.apiResult.textContent = res.success ? res.payload : "Lost"; };
el.quoteBtn.onclick = async () => { el.apiResult.textContent = "Fetching..."; const res = await callBG('GET_QUOTE'); el.apiResult.textContent = res.success ? `"${res.data.content}" - ${res.data.author}` : "Fail"; };
el.dogBtn.onclick = async () => { el.apiResult.textContent = "Fetching..."; const res = await callBG('GET_DOG'); if (res.success) { el.apiResult.innerHTML = `<img src="${res.url}" style="width:80px; border-radius:8px">`; } };
init();
